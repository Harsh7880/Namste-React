Question: What is the difference between Named Export, Default export and * as export?
Ans: 

Named Export:
With named exports, you can export multiple functions, objects, or variables from a module by name.
These exports can then be imported by their specific names in other modules.

Default Export: Default export is used to export a single function, object, or variable from a module.
Unlike named exports, you can import a default export under any name you want in the importing module.

* as Export: The * as syntax allows you to import all exported members of a module under a single namespace in the importing module.
This is useful when a module exports a large number of functions, objects, or variables and you want to import them all under a single name.

Question: What is the importance of config.js file
Ans: A config.js file is often used in software development to store configuration variables, settings, 
or constants that are used across an application. Its importance lies in several aspects:
Benifites : 
    1) Centralized Configuration
    2) Maintainability
    3) Consistency
    4) Security
    5) Scalability

Question: What are React Hooks?
Ans: React Hooks are normal JavaScript functions that allow developers to use state and other React features in 
functional components. Before the introduction of Hooks, functional components in React were stateless and couldn't 
directly use lifecycle methods or state. With Hooks, functional components can now use state and other React 
features without needing to convert them into class components.

useState: Allows functional components to use state variables.

useEffect: Allows functional components to perform side effects (such as data fetching, subscriptions, or manually changing the DOM) after the component renders.

useContext: Allows functional components to consume context within the React tree.

useReducer: An alternative to useState, often used for more complex state logic.

useCallback: Memoizes functions to prevent unnecessary re-renders in child components.

useMemo: Memoizes the result of a function to prevent re-computation during re-renders.

useRef: Allows functional components to create mutable variables that persist between renders.

useLayoutEffect: Similar to useEffect, but runs synchronously after all DOM mutations. It can be useful for measuring DOM nodes or implementing custom layout effects.

Question: Why do we need a useState Hook?
Ans: The useState Hook in React is crucial because it enables functional components to have local state. 
Before the introduction of Hooks, functional components were stateless and could not manage their own state. 
This limitation meant that developers often had to refactor functional components into class components whenever 
state management was necessary, leading to more complex code and potentially decreased readability.

The useState Hook solves this problem by allowing functional components to define and update their own state \
without converting them into class components. Here's why useState is essential: